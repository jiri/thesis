// Helpers {{{

alpha = [a-zA-Z]

digit = [0-9]

hexdigit = #quiet<[0-9a-fA-F]> / #expected("a hexadecimal digit")

identifier = [a-zA-Z_][a-zA-Z_0-9]*

ws = [ \t]

comma = ws* "," ws*

// }}}

// Operands {{{

u16_dec -> u16
    = s:$(digit+) {? u16::from_str_radix(s, 10).map_err(|_| "Error when parsing int") }

u16_hex -> u16
    = "$" s:$(hexdigit+) {? u16::from_str_radix(s, 16).map_err(|_| "Error when parsing int") }

u16 -> u16 = u16_dec / u16_hex

register -> Register
    = "R" v:$(digit*<1,2>) {? Register::new(v.parse::<u8>().unwrap()) }

byte -> u8
    = v:$(hexdigit*<1,2>) { u8::from_str_radix(v, 16).unwrap() }

label -> Label
    = i:$(identifier) { Label::from(i) }

// }}}

// Instructions {{{

db -> Instruction
    = ".db" ws+ bs:byte ** comma { Instruction::Db(bs) }

org -> Instruction
    = ".org" ws+ addr:u16 { Instruction::Org(addr) }

add -> Instruction
    = "add" ws+ r0:register comma r1:register { Instruction::Add(r0, r1) }

addi -> Instruction
    = "addi" ws+ r:register comma i:u16 { Instruction::Addi(r, i) }

jmp -> Instruction
    = "jmp" ws+ l:label { Instruction::Jmp(l) }

// Instructions }}}

// Instruction sets {{{

arithmetic -> Instruction
    = add / addi

// }}}

/// Basic constructs {{{

label_definition -> Label
    = l:label ws* ":" { l }

instruction -> Instruction
    = db / org / arithmetic / jmp

comment = ";" [^\n]*

line -> Line
    = ws* l:label_definition? ws* i:instruction? ws* comment? { Line { label: l, instruction: i } }

pub program -> Vec<Line>
    = line ** ("\n"+)

// }}}
