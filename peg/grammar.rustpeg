// Helpers {{{

alpha = [a-zA-Z]

digit = [0-9]

hexdigit = #quiet<[0-9a-fA-F]> / #expected("a hexadecimal digit")

identifier = [a-zA-Z_][a-zA-Z_0-9]*

ws = #quiet<[ \t]>

comma = ws* "," ws*

// }}}

// Operands {{{

u16_dec -> u16
    = s:$(digit+) {? u16::from_str_radix(s, 10).map_err(|_| "Error when parsing int") }

u16_hex -> u16
    = "$" s:$(hexdigit+) {? u16::from_str_radix(s, 16).map_err(|_| "Error when parsing int") }

u16 -> u16 = u16_dec / u16_hex

register -> Register
    = "R" v:$(digit*<1,2>) {? Register::new(v.parse::<u8>().unwrap()) }

u8_dec -> u8
    = s:$(digit+) {? u8::from_str_radix(s, 10).map_err(|_| "Error when parsing u8") }

u8_hex -> u8
    = "$" s:$(hexdigit+) {? u8::from_str_radix(s, 16).map_err(|_| "Error when parsing int") }

u8 -> u8 = u8_dec / u8_hex

label -> Label
    = i:$(identifier) { Label::from(i) }

address -> Address
    = l:label { Address::Label(l) } / u:u16_hex { Address::Immediate(u) }

flag -> Flag
    = "z" { Flag::Z } / "o" { Flag::O }

// }}}

// Instructions {{{

db -> Instruction
    = ".db" ws+ bs:u8 ** comma { Instruction::Db(bs) }

ds -> Instruction
    = ".ds" ws+ len:u16 { Instruction::Ds(len) }

org -> Instruction
    = ".org" ws+ addr:u16 { Instruction::Org(addr) }

nop -> Instruction
    = "nop" { Instruction::Nop }

mov -> Instruction
    = "mov" ws+ r0:register comma r1:register { Instruction::Mov(r0, r1) }

movi -> Instruction
    = "movi" ws+ r0:register comma i:u16 { Instruction::Movi(r0, i) }

add -> Instruction
    = "add" ws+ r0:register comma r1:register { Instruction::Add(r0, r1) }

addi -> Instruction
    = "addi" ws+ r:register comma i:u16 { Instruction::Addi(r, i) }

addc -> Instruction
    = "addc" ws+ r0:register comma r1:register { Instruction::Addc(r0, r1) }

jmp -> Instruction
    = "jmp" ws+ addr:address { Instruction::Jmp(addr) }

load -> Instruction
    = "load" ws+ r:register comma addr:address { Instruction::Load(r, addr) }

store -> Instruction
    = "store" ws+ addr:address comma r:register { Instruction::Store(addr, r) }

brif -> Instruction
    = "brif" ws+ f:flag comma addr:address { Instruction::Brif(f, addr) }

brnif -> Instruction
    = "brnif" ws+ f:flag comma addr:address { Instruction::Brnif(f, addr) }

// Instructions }}}

// Instruction sets {{{

special -> Instruction
    = db / org

basic -> Instruction
    = nop / mov / movi

arithmetic -> Instruction
    = add / addi / addc

memory -> Instruction
    = load / store

branching -> Instruction
    = jmp / brif / brnif

// }}}

/// Basic constructs {{{

label_definition -> Label
    = l:label ws* ":" { l }

instruction -> Instruction
    = special / basic / arithmetic / memory / branching

comment = ";" [^\n]*

pub line -> Line
    = ws* l:label_definition? ws* i:instruction? ws* comment? { Line { label: l, instruction: i } }

// }}}
